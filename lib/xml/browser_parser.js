var util = require('../util')
var Shape = require('../model/shape')
var xml2js = require('xml2js')

function DomXmlParser() {}

DomXmlParser.prototype.parse = function (xml, shape) {
  if (xml.replace(/^\s+/, '') === '') return {}

  var resultKen

  var OPTIONS = {
    // options passed to xml2js parser
    explicitCharkey: false, // undocumented
    trim: false, // trim the leading/trailing whitespace from text nodes
    normalize: false, // trim interior whitespace inside text nodes
    explicitRoot: false, // return the root node in the resulting object?
    //emptyTag: null,         // the default value for empty nodes; Null cannot be used in S3, otherwise the object generated by the space will not be recognized
    explicitArray: false, // always put child nodes in an array
    ignoreAttrs: true, // ignore attributes, only create text nodes
    mergeAttrs: false, // merge attributes and child elements
    normalizeTags: true // key 小写
  }
  var parser12 = new xml2js.Parser(OPTIONS)

  parser12.parseString(xml, (err, result) => {
    resultKen = result
  })

  return resultKen
}

function getElementByTagName(xml, tag) {
  var elements = xml.getElementsByTagName(tag)
  for (var i = 0, iLen = elements.length; i < iLen; i++) {
    if (elements[i].parentNode === xml) {
      return elements[i]
    }
  }
}

function parseXml(xml, shape) {
  if (!shape) shape = {}
  switch (shape.type) {
    case 'structure':
      return parseStructure(xml, shape)
    case 'map':
      return parseMap(xml, shape)
    case 'list':
      return parseList(xml, shape)
    case undefined:
    case null:
      return parseUnknown(xml)
    default:
      return parseScalar(xml, shape)
  }
}

function parseStructure(xml, shape) {
  var data = {}
  if (xml === null) return data

  util.each(shape.members, function (memberName, memberShape) {
    if (memberShape.isXmlAttribute) {
      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
        var value = xml.attributes[memberShape.name].value
        data[memberName] = parseXml({ textContent: value }, memberShape)
      }
    } else {
      var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name)
      if (xmlChild) {
        data[memberName] = parseXml(xmlChild, memberShape)
      } else if (!memberShape.flattened && memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {
        data[memberName] = memberShape.defaultValue
      }
    }
  })

  return data
}

function parseMap(xml, shape) {
  var data = {}
  var xmlKey = shape.key.name || 'key'
  var xmlValue = shape.value.name || 'value'
  var tagName = shape.flattened ? shape.name : 'entry'

  var child = xml.firstElementChild
  while (child) {
    if (child.nodeName === tagName) {
      var key = getElementByTagName(child, xmlKey).textContent
      var value = getElementByTagName(child, xmlValue)
      data[key] = parseXml(value, shape.value)
    }
    child = child.nextElementSibling
  }
  return data
}

function parseList(xml, shape) {
  var data = []
  var tagName = shape.flattened ? shape.name : shape.member.name || 'member'

  var child = xml.firstElementChild
  while (child) {
    if (child.nodeName === tagName) {
      data.push(parseXml(child, shape.member))
    }
    child = child.nextElementSibling
  }
  return data
}

function parseScalar(xml, shape) {
  if (xml.getAttribute) {
    var encoding = xml.getAttribute('encoding')
    if (encoding === 'base64') {
      shape = new Shape.create({ type: encoding })
    }
  }

  var text = xml.textContent
  if (text === '') text = null
  if (typeof shape.toType === 'function') {
    return shape.toType(text)
  } else {
    return text
  }
}

function parseUnknown(xml) {
  if (xml === undefined || xml === null) return ''

  // empty object
  if (!xml.firstElementChild) {
    if (xml.parentNode.parentNode === null) return {}
    if (xml.childNodes.length === 0) return ''
    else return xml.textContent
  }

  // object, parse as structure
  var shape = { type: 'structure', members: {} }
  var child = xml.firstElementChild
  while (child) {
    var tag = child.nodeName
    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
      // multiple tags of the same name makes it a list
      shape.members[tag].type = 'list'
    } else {
      shape.members[tag] = { name: tag }
    }
    child = child.nextElementSibling
  }
  return parseStructure(xml, shape)
}

/**
 * @api private
 */
module.exports = DomXmlParser
